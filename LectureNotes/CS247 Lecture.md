# CS247 Lecture

## Lecture 1 May 6 2019

Prof Robert Hackman

SE is to improve quality, productivity, larger systems, evolvability

More real world focus 

ADT Design, -- productivity 

Modules and Interfaces

Exceptions

Interface Specifications

OO design Principles 

Design Patterns 

UML modelling -- productivity 

Generic Programming (Templates, STL)

Testing/Debugging 

Monday 3:30 - 5 

12 Hours of Module Design

12 OO

Thinking in C++ need to read those 

15% Assignments 

A1 May 24

A2 June 14 

A3 July 30 

5% each 

Between A2 and A3 are projects 

Project 2 or 3 people 

Group of 3 best 

July 19-21 do the demo 

must be able to run and compile linux.students.cs.uwaterloo.ca

June 28/July 16 demo projects

Midterm 20% Final 50%

Tutorials, introduce tools and more examples, discussing assignment
 
C++ has inheritance 

Private and Public 

MyClass C in C++: 

Default Constructor

Riase level of abstraction, interfaces 

Reuse 

Modularity 

Information Hiding

Polymorphism 

## ADT Design 

Abstract Data type, user defined, implementation might vary but same methods 

Bundles together 

1. Range of Valid Values/Data
2. Functions over those values 

Ideally use help of compiler to enforce users to use it properly 

* ADT allow us to employ outside in design 

Basically encapsulating a convoluted data and make it clearer for the client to use it, just knowing the interface, not how it's done 

Client - Interface - Implementation Details 

```
#include <iostream>

using namespace std

int main() {
    cout << "Enter a rational(a/b): ";
    Rational r, p, q;
    cin >> r, 
    cout << "Enter a ratioanl(a/b):";
    cin >> q;
    cout << r;
    p = q + r;
    cout << p;
    cout << q / p;
}
```

default constructor? No params 

overload input operator with istream& and a rational&, mutate that object

overload output operator with ostream& and a rational& or not (should const) faster, no copy 

can't copy the streams 

overload additional operators with rationals 

pass rationals const reference 

return by value for rational -- created a new value 

assignment operator -- copy & move 

division opereator 

copy constructor Rational z(q) 

big 3:

destructor, copy constructor, copy assignment operator -- exception free 


## May 6th After Lecture

### UML Diagrams

diamond is association, 

inheritance, arrow points from derived class to base class 

is a vs is like a 

interchangeable objects with polymorphism 

late binding vs early binding OOP uses late binding 

virtual functions

```
void doStuff(Shape& s){
    s.erate();
    s.draw();
}

Circle C;
Triangle t;
doStuff(c);

This does the right thing 

```

treat a derived type as if it is a base type upcasting 

new and delete 

garbage collector for C++ is handled by programmers 


Exception handling 

Exception is an object thrown from site of error and can be caught by exception handlers 

declaration vs definition 

extern key word: definition is external to the file, or occurs later

headers 

linking 

linker collects object modules like .o or .obj generated by compiler 

Link the library into the executable program. 

class member function abc::aaa();


short int, int, long int

float, double, long double

singed, unsigned 

declare it using ::, use using dot

Destructor always same name but with ~symbol 

at most one destructor 

for class with pointer data 

a global
object is destroyed when program execution is completed; an automatic object is
destroyed when its scope is left; and a dynamic object is destroyed when the
delete operator is applied to it.

friend function

```
class RealSet{
friend void IntSet::SetToReal (RealSet&)
}

void IntSet::SetToReal (RealSet &set)
{
set.card = card;
for (register i = 0; i < card; ++i)
set.elems[i] = (float) elems[i];
}

```

default argument 

```
public:
    Point(int x = 0; int y = 0);
```

Within the body of the member function,
one can refer to this implicit argument explicitly as this, which denotes a pointer to
the object for which the member is invoked. 

```
Point::OffsetPt (int x, int y)
{
this->xVal += x; // equivalent to: xVal += x;
this->yVal += y; // equivalent to: yVal += y;
}
```

member initialization list
```

class Image {
public:
Image (const int w, const int h);
private:
int width;
int height;
 //...
};
Image::Image (const int w, const int h) : width(w), height(h)
{
//...
}

```

```
Bool Set::Member (const int elem) const
{
//...
}
for constant memeber function
```

A data member of a class can be defined to be static. This ensures that there will
be exactly one copy of the member, shared by all objects of the class. 


## Lecture 2 5/8 

default constructor 

parameterized constructor 

input operator overload 

```
Rational P;
Rational q {3, 5};
cin >> p;
cout << a << endl;
cout << p + q << endl;
rational Z {p, q }

```
operator + overload 

operator / overload 

copy constructor 

Does an ADT have to be a class 

No. Struct my ADT works 

Initialization is guaranteed constructors destructors 

enforce legal value range / can't do in C 

visibility of fields 

should a class always have a default constructor?

No. There are cases you NEED to pass your initialization value 

move constructor? 



Object construction in C++ 

1. Allocate Space 
2. Initialize superclass components 
   -- superclass will be default constructed unless told how to initialize it 
3. initialize all fields which are objects -- default unless otherwise
4. construct body elements 

MIL is now to tell compilers what constructors to use with which value 

without MIL you won't be able to default initialize the super class 

why use MIL

* need to if fields or superclass doesn't have a default constructor 

```
class A {
    public:
    A(int x) ...{ }
}

class B {
    A a;
    Public:
    B(){A.setX = 5} // before constructor body runs, trys to default construct A, but doesn't exist
}
```

* speed: if you don't initialize properly in MIL, field/superclass get default constructed, then you waste that time when you overwrite that default construction in the body. Better to do it the first time. 

-- smart pointer: delete automatically 

```
//+ between rationals
- between rationals
- << ostream and rational 
- >> operator >> between istream and rational 
should these be memeber function?
can they be?

cin >> r //first argument is istream

cout << r; 

overloaded operators as member functions always take object itself as the first parameter 

cannot support because first argument is different 


class Rational {
    int num_, den_;
    public:
        Rational(): num_{0}, den_{0} {} // member initialization list 
        Rational(int num): num_{num},den_{1} {}
        Rational(int num, int den): num_{num},den_{den} {}

        //use default parameter values
        easier to write:
        Rational(int num = 0, int den = 1) num_{num}, den_{den} {}
        //default parameters must be trailing : last n parameters after first default parameter, the after ones are default too
        Rational(const Rational &r): num_{r.num_}, den_(r.den_) {} 
        Rational operator + (const Rational& r ){
            //itself is *this 
        } //member function 
        //first param is implicitly the rational pointed to by the this pointer 
        // no choice of first parameter 
}

```

can't take the base class, but you can take the derived class

A <- B

foo (B b);
A a;
B b;
foo(a); //doesn't work 

output and input CAN't be member functions 

In general prefer non-member non-friend functions 

## Tutorial 1 

Legal value 

explicit Rational (int num)

constructor initalizes new object to a legal value 

Rational a = 4 

rational n = rational {4}

accessor don't change anything in your class 

overloading -- same function name for variants of the same function

different argument signatures

non member functions 

## Lecture 3

copy assignment operator

```
Rational& operator = (const Rational & other) {
  num = other.num_
  den = other.den_
  //not a constructor, no MIL 
  return *this; 
}

```
copy constructor 

```
Rational(const Rational & other) : num_{other.num_}, den_{other.den_}

```

friend Rational operator + (const Rational& lhs, const Rational& rhs){
// no implementation here, inside class
} // non member function, cannot access private information
// need to use friend fucntion 

outside class 

Rational operator + (const Rational& lhs, const Rational & rhs) {
 Rational p {lhs.num * rhs.den + rhs.num * lhs.den, lhs.den * rhs.den };
 retrun p;
}

or make it a member function:

Ratioanl operator+ (const Rational & rhs){
  ...
}

r = s, Copy Assignment Operator
s will be implicityly cast to s / 1 

Rational operator+ (int x){
  return Rational { x * den_ + num, den_}; // can do r + 7 but not 3 + r 
} //member function, doesn't work well

friend Rational operator+ (int x, const Rational &){
}

Ratioanl operator+(int x, const Rational& R){
  //
}

 
Rational r {1,2}

Rational p = r + 7,

Rational q = 3 + r

cin >> q >> p >> r;
cout << p; 

needs setters/getters or friend function

friend Ostream& operator <<(ostream&, const Rational &);
friend istream& operator >>(istream&, Rational&);

OStream & operator <<(Ostream& out, const Rational& r ){
  out << "r << r.num_... ;
}

istream& operator >> (istream & in, Rational & r){
  return in>>r.num_ >> r.dm_;
}


Class Node {
  int data_;
  Node* next_;
  Public:
    Node(int data, Node* next_ = nullptr): data_ {{data}, next{next_}
    Node(const Node& other): data{other.data}, next{
      other.next ? new Node{*other.next} : nullptr
    } {}
}

Node n {3, new node{ 2, new NOde{1}}},

3 -> 2 -> 1 

cout << n; 
Node p {n};
p.next -> data = 20,
cout << p // 3, 20, 1
cout << n // 3, 2, 1

deep copy, copy a whole new linked list

## Lecture 4 
```
#include <utility>

Class Node {
  int data_;
  Node* next_;
  Public:
    Node(int data, Node* next_ = nullptr): data_ {{data}, next{next_}
    Node(const Node& other): data{other.data}, next{
      other.next ? new Node{*other.next} : nullptr
    } {}
    ~Node(){
        //when object out of scope(stack) or deleted 
        //when new, always delete 
        delete next; // recursively called;
    }
    Node( Node && o) : next{o.next}, data{o.data // std::move(o.data)}{
        o.next = nullptr;
    } //rvalue reference, move constructor, copying an rvalue
    Node & operator=(const node & other){ //copy assignment operator
       Node* tmp = new Node{other};
       data = other.data;
       delete next; //can't fail
       next = temp; //can't fail
       retrun *this;

       //new version
       Node* temp{other};
       swap(data, tmp.data);
       swap(next, temp.next);
       return *this;
    } 

    Node & operator = (Node && other){ //rvalue reference again
        //need to deallocate previous next ptr 
        using std::swap,
        swap(data other.data);
        swap(next, other.next);
        return* this;
        /*
        data = other.data;
        delete next;
        next = other.next;
        other.next = nullptr;
        return *this;
        */ //too long
    }
}

Node n {3, new node{ 2, new NOde{1}}},

Node foo(){
    Node n...
    return n;
} // return node by value

int main(){
    Node n = foo(); // rvalues, temporary values, only exists here 
    //return value guaranteed not to exist after this statement 
}
```

lvalue is guaranteed to have a memory address

void bar(int & x){
    x = sss;
}
bar(5+3); //doesn't work

can't call bar on a r value because its type is an lvalue ref, make exception if its constant

The big 5 

destructor 

copy assignment operator

copy constructor

move constructor

move assignment operator


std::move takes in any type and returns an rvalue version of it 


## Lecture 5 

```
Node & Node::Operator=(const Node & other){ Copy Assignment operator

  delete next;
  next = new Node {*other.next};
  data = other.data;
  return *this;
}
```

new fails then dangling pointer;

n = n? 

Then other is the same object, so delete next would 

try deep copy it would get memory error 

check for self assignment 

2 objects are the same when same memeory address

if(this == & other) return *this;

General Rule of thumb: if you have to provide a user defined definition for one of the big 5, you should for all 5.

No hard rule when you need these, need to figure out when you actually write those, but at least when you have resources you need to maintain 

e.g Memory, Socket, File ptr etc...

when are these used ? 

- Destructor, when an object goes out of scope
- heap/dynamically allocated would be delete abc 
- statically allocated when their life time ends, when their enclosing scope ends 

Definition: static memory allocation is the allocation of memory at compile time, before the associated program is executed, unlike dynamic memory allocation or automatic memory allocation where memory is allocated as required at run time.

Class A{
  B b;
}

A &p = new A;

A object pointed to by p is dynamically allocated

p -> b is on the heap bits 

no need to delete a->b because its lifetime is tied to 

copy ctor is called 

- when you construct one object with another one of the same type 

- when a function receives an object param by value 

- when a function returns by value 

EXCEPT 

- when a move constructor is defined then it is used to return by value 

if the other cases use an rvalue as argument then the move ctor is used 


Compiler provides builtin impelmentations of thse for you 

copy ctor -- bytewise copies all PoD(built in types not String) fields and copy constructs all object fields 

same with move constructor 

copy assignment operator bytewise all PoD fields and copy assigns all object fields 

define CAO you would lose builtin MAO, just one way

If you define a copy constructor, you lose builtin move constructor , one way

### ADT 

Abstracting some complex idea of data 

enforce rules on that data e.g a valid range of values 

Node n {3, new node{2, nullptr}}{
  Node p{4, &n}
}

P goes out of scope, p's destructor runs, calls delete on its next pointer, a statistically allocated address 

can't call delete on stack allocated address 

we have some rules that must hold for our ADT to work properly 

Assumptions are claled invariants - properties that must hold true for code to work properly 

Client Code writer CANNOT be trusted to uphold your invariants 

Don't expect clients to remember the rules 

## Tutorial 2 

Inheritance 

Polymorphism 
derived class that public inherits from a base calss, 

use base class pointers to point to objects of derived type

access things that doesn't exist in the base class is wrong 

static binding:

By Default: binding of functions occurs at compile time

if call a member function from a polymorphic base class pointer, 

function called will be the base class implementation 

regardless of the actual object pointed to 

Virtual functions: dynamic binding, so it will find the actual class of the object pointed to. 

```
class Bear : public Animal{

}

```

Functions with multiple definitions 

Overriding, overloading 

Overriding: subclass with the same name function compared to super class 

member objects : initialized using member's default constructors 

inherited objects: initialized using base class default constructor 

Copy Constructor 

Node::Node(const Node & other){
  data(other.data),
  next(other.next ? )
}

copy and swap idiom 

avoid code duplication 

Assignment operator may be implemented by creating a new object of the same type with the copy constructor then swapping the old values of the obejct 

use std::swap 

Move: argument is rvalue reference

and resource in the argument is stealed to the object created or assigned 


MIL 

references and const members cannot be initialized outside the initialization list 

Any object not initialized in MIL will have its default constructor called 


## Lecture 6 

Invariants - Assumptions that must hold true for our code to work properly, hard/impossible to reason about code without them. 

```
Class Node{
  int data;
  Node *next;
  Public:
    Node(int d, Node* next){

    } -- no cycles 
    ~NOde(){delete next;}
}
```

Each next pointer must point at a valid heap allocated node, or the null ptr

Node assumes ownership of the next pointer 

Must be able to delete it 

No cycles, No sharing of next pointers 

curretnly in constructor they can do whatever they want to the Node* next parameter 

can't guarantee client behavior 

Allowing the client to use this constructor is dangerous, as allowing them to see Node or linked list at all is represnetation exposure 

The ADT we want to give to the client is a list : they should not have to care about the implementation 

it is a linked list of nodes here, but they don't need to care 

- what we want is to encapsulate the implementation logic, hide it away from client 

Give the client a list class 

//list.h 
```
class List {
  class Node { // private nested class 
    //same implementation
    friend class List;
  }
  Node *head;
  Public: 
    List()head{nullptr}{}
    List& push(int data);
    // big 5 for list, reusing Node code
    int& ith(size_t i);
}
```
//list.cc 

header file, i.e interface file  for .h 

.cc implmenetation, seperate compilation 
```
List::Node::Node(int data, Node* next) //how you use private nested class 
List& List::push(int data){
  head = new Node{data, head};
  return *this;
}
int & List::ith(size_t i){
  Node* Node = head;
  while(i > 0 && node){
    --i;
    node = node->next;
  }
  return node->data;
}
```
Client code:

```
#include<iostream>
using namespace std;

list l;
size_t en;
for(size_t i = 0;i < len; ++i){
  cout<< l.ith(i) <<endl;
}  // O(N^2)
```

- ith is O(n) and it's bad 
- don't have to call ith everytime they want to iterate through it 
- give the user a similar way to iterate over their list as they did before without exposing the representation 

what we want is an iterator 

Client code:

```
List l ;
for (thing = beginning of list, thing  != end of list; ++ thing){
  *thing = *thing + i;
  cout << *thing;
}
```

For iterator:
- get beginning of the list : iterator list::begin()
- get end of the list : iterator list::end()
- ++ work on the iterator 
- iterator::operator++()
- dereference operator iterator::operator*()
- inequality/equality operator between iterators


## Lecture May 22 

Office hour wednesday 3:30 - 5 

DC2128 

for(iterator = beginning; iterator != end of list; ++iterator){
  cout << *iterator << "";
  *iterator = *iterator + 1;
}

begin - in list, creates an iterator to beginning of collection 

end - in list, creates an iterator to end of collection, one pass the end, since iterator != end, doesn't print it 

Operator != for iterators 

Operator ++ for iterators 

Unary * operator for iterators 

```
class List {
  Node* head;
  Public:
    class Iterator{
      Node * cur;
      Iteraotr(Node*);
      public:
        bool operator != (const Iterator&);
        Iterator& operator++();
        Int& operator*();
        friend class List;
    }
  Iterator begin();
  Iterator end();
}

//list.cc 

List::Iterator List::begin(){
  return Iterator{head};
}

List::Iterator List::end(){
  return Iterator{nullptr};
}

List::Iterator:Iterator(Node* n):cw{n}{}

bool List::Iterator::operator != (const List::Iterator & other){
  return cur != other.cur //are they pointing to the exact same location?
}

reverse iterators are different things than this iterator, so no -- 

List::Iterator& List::Iterator::operator++(){ //for post index then add a integer parameter, this is prefix so no int parameter
//post fixed returns the old value
//preferred prefix
cur = cur->next;
return *this;
}
```

int& List::operator*(){
  return cur->data
}

List l:
for(List::Iterator it = l.begin();it != l.end(); ++it){
  cout << *it << ";
  *it = *it + 1;
}

for(auto it = l.begin(); it != l.end(); ++it ){
  same as before, compiler deduces type of it 
  
}//only if it's unambiguous 

The iterator pattern, first design pattern

Iterator Pattern is a common solution to a common problem 

Not necessarily exactly solution 

"This is not exactly the code you should write" but "give a problem like x, maybe y or something like it is a good solution"

C++ has specific syntax for classes that implement the iterator pattern 

Range for loop
for(auto& x : l){
  cout << x  << endl
}

To use a range for loop on a class x, there must be a function x::begin(), that returns a Y 

x::end() that returns a Y 

overloaded operator++ for Y 

overloaded operator:= for Y 

overload operator* unary for Y 

Specific pattern



## Lecture 7 

Entity ADTs and value ADTs

Entity 

- ADT that reflects an entity in the real world hence the name 
- We should not allow copying, either via constructor or assignment operator, typically, because it doesn't make sense 
- if necessary, can implement a clone method 

think twice before overloading operators for them 

except move assignment and if necssary copy assignment 

prefer to avoid implmeneting type conversion functions 

Value ADT 

just represent some sort of value, like measurement value etc 

Allow copying since it's just a value 

typically disallow mutation of individual fields 

allow overloaded operators as necessary 

example of entity ADTs 

-people, planes,available runways, bookings etc ...

example of value ADTs,

Rationals, List, units of measurement, points, forces etc...

Birthdate 

making a card game for example, 

Deck - entity 

Card - entity, actual physical card 

Suit - value, it represents an attribute of a card, no actual physical suit 

Player - entity 

Score - value 


License Plate ADT

3 letters follows by a hyphon and then 3 numbers 

4 letters followed by a hyphon and then 3 numbers 

vanity plate, one with 8 or less characters or numbers mininum 2 

Default constructor generate the next available plate 

parameterized constructor, take in string for vanity plate 

operator < for sorting inclusion in sorted containers 

Make assumptions for default constructors 

plates are always issued in order 

vanity plates may not take the place of a non vanity plate 

when we create a license plate, we need some information about all the license plates created before 

we need some kind of state that is maintained not just within the life time of an object, but across the entirety of that class

static variable of a class 

static with regards to members of class, when applied, means that member is tied not to an individual object, but the class as a whole 

a static member variable is essentially a global variable 

All objects share the same variable 

static member functions are also meant to be part of the class as a whole

take no *this pointer, can't access anything in class besides static members 
```
Class Foo {
  int x;
  public:
    static int count; //can't initialize it to 0 inside declaration 
    Foo(int x): x{x} {
      ++ count;
    } //if you initialize with count = 0, then it will try to reinitialize count which already exists
    Static void printCount(){
      std::cout << count << std::endl;
    }
}
```

```
//foo.cc 
int Foo::count = 0; // define it here 

int main(){
  Foo f{5}; 
  Foo f{2};
  cout << f.count << "  " f2.count << endl; //both should be 2 
  cout << Foo::count << endl //2 as well
  Foo f3{7};
  f.printCount(); 
  Foo::printCount();//tied to classes, and that's why you can't access stuff like f.number in static functions 
}

definition and declaration 
```

declare it as many time as you want, define once 
```
Class Foo;

Class Foo{
  //actual 
}
```

```
class LicensePlate {
  static std::String nextAvailable;
  std::string plateNo;
  static void updateAvailable();
  public:
  LicensePlate();
  LicensePlate(std::string);
  bool operator < (const LIcensePlate & other);
}
```


## Lecture 8

license plate 


header file can be included twice, but you can only define something once. 

Don't wanna repeat yourself here

like 

```
//a.h 
#include "b.h"

//c.h
#include "a.h"
#include "b.h"



```

license.h

```
#ifndef LICENSE_H //header guard
#define LICENSE_H
#include <string>

class LicesnePlate{
    static int fourDigits;
    static char charOne,charTwo,charThree;
    static void updateNextAvailable();
    std::string plateNo;
  public:
    Licesne();
    Licesne(std::string name);
    bool operator <(const LicensePlate &other) const; //rhs is const, lhs is const too;
}

#endif


```


license.cc 

why not put namespace std in header file?

it would pollute the global namespace: it would pull in everything in that namespace 

do not have a using directive in the header file 



```
#include "license.h"
#include <string> 
#include <iomanip>
#include <sstream>
using namespace std;

int License::Plate::nextAvailable = 0;
char LicensePlate::charOne = 'A';
char LicensePlate::charTwo = 'A';
char LicensePlate::charThree = 'A';
void LicensePlate::updateNextAvailable(){
  if(fourDigits < 9999){
    ++fourDigits;
    return;
  }else if(charThree == 'Z'){
    if(charTwo == 'Z'){
      ++charOne;
      charThree = charTwo = 'A';
    } else{
      ++charTwo;
      charThree = 'A';
    }
  }
  charThree++;
}

//stringstream class

setw() //set width, but with white space
setFill() //set the filled charater


LicensePlate::LicensePlate(){
  stringstream ss;
  stringstrema charStream:
  ss << setfill('0') << setw(4);
  ss << fourDigits;
  charSteram << charOne << charTwo << charThree << "-";
  string numberString;
  ss >> numberString;
  ...
}

LicensePlate::LIcensePlate(string plateNo):plateNo{plateNo} {}

bool licensePalte::operator<(const LicensePLate &other) const{
  return *this < other;
}
```

always g++ -std=c++14 -c 


## Lecture May 29th 

Code see above 

```
int main(){
  LicensePlate p1;
  string vanity;
  cin >> vanity;
  LicensePLate p2{vanity};
  LicensePlate p3;
}

```

create the copy constructors as private functions 

LicensePlate(const LicensePlate &) = delete; in header file, means delete builtin constructor 
same thing with assignment operator

this would cause an error message 

Wrote your class but no main to test it 

at least compile the classes 

g++ -std=c++14 -c myfile.cc //-c compile only don't link my code yet 

myfile.cc -> myfile.o 

very important as we need it for seperate compilation 

g++ -std=c++14 -c license.cc -> produced license.o
g++ -std=c++14 -c main.cc ->produced main.o

g++ license.o main.o -o myprogram // then link together to my program

what happens if I change main.cc ?

- First example, only need to run linking again, don't need to compile license.cc again 

what if license.h changes?

recompile every .cc module that has a true compilation dependency with license.h 

if something has a true compilation dependency, means it says include "x.h"

now it doesn't mean if you include then it's true compilation dependency 

when does a true compilation dependency exist? when the compiler needs to know of the contents of the .h file when compiling the cc module 

you use functions declared in classes in that module, specifically member functions 

OR you construct and allocates object of that type , as you need at least how large an object is for a compiler 

if you don't have a true compilation dependency, don't introduce one by including files, just forward declare 

```
a.h 

class A{

}

b.h 

class B{
  A* a;  forward declaration is enough, not an actual object but a pointer 
}

c.h 

class C{
  A a; true compilation dependency because you need to know how big A is 
}

d.h 

class D{
  A& a; no 
}

e.h 

class E: public A{
  //need to include a.h 
}

f.h

class F{
  A myFn(A a); //no, because you don't use functions declared here in the header file 
}

```

should forward declare as much as possible;

include only when necessary 

together we'll call a .h file, interface file, and it's corresponding .cc file, implementation file

those are a module 

