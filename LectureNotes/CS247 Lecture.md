# CS247 Lecture

## Lecture 1 May 6 2019

Prof Robert Hackman

SE is to improve quality, productivity, larger systems, evolvability

More real world focus 

ADT Design, -- productivity 

Modules and Interfaces

Exceptions

Interface Specifications

OO design Principles 

Design Patterns 

UML modelling -- productivity 

Generic Programming (Templates, STL)

Testing/Debugging 

Monday 3:30 - 5 

12 Hours of Module Design

12 OO

Thinking in C++ need to read those 

15% Assignments 

A1 May 24

A2 June 14 

A3 July 30 

5% each 

Between A2 and A3 are projects 

Project 2 or 3 people 

Group of 3 best 

July 19-21 do the demo 

must be able to run and compile linux.students.cs.uwaterloo.ca

June 28/July 16 demo projects

Midterm 20% Final 50%

Tutorials, introduce tools and more examples, discussing assignment
 
C++ has inheritance 

Private and Public 

MyClass C in C++: 

Default Constructor

Riase level of abstraction, interfaces 

Reuse 

Modularity 

Information Hiding

Polymorphism 

## ADT Design 

Abstract Data type, user defined, implementation might vary but same methods 

Bundles together 

1. Range of Valid Values/Data
2. Functions over those values 

Ideally use help of compiler to enforce users to use it properly 

* ADT allow us to employ outside in design 

Basically encapsulating a convoluted data and make it clearer for the client to use it, just knowing the interface, not how it's done 

Client - Interface - Implementation Details 

```
#include <iostream>

using namespace std

int main() {
    cout << "Enter a rational(a/b): ";
    Rational r, p, q;
    cin >> r, 
    cout << "Enter a ratioanl(a/b):";
    cin >> q;
    cout << r;
    p = q + r;
    cout << p;
    cout << q / p;
}
```

default constructor? No params 

overload input operator with istream& and a rational&, mutate that object

overload output operator with ostream& and a rational& or not (should const) faster, no copy 

can't copy the streams 

overload additional operators with rationals 

pass rationals const reference 

return by value for rational -- created a new value 

assignment operator -- copy & move 

division opereator 

copy constructor Rational z(q) 

big 3:

destructor, copy constructor, copy assignment operator -- exception free 


## May 6th After Lecture

### UML Diagrams

diamond is association, 

inheritance, arrow points from derived class to base class 

is a vs is like a 

interchangeable objects with polymorphism 

late binding vs early binding OOP uses late binding 

virtual functions

```
void doStuff(Shape& s){
    s.erate();
    s.draw();
}

Circle C;
Triangle t;
doStuff(c);

This does the right thing 

```

treat a derived type as if it is a base type upcasting 

new and delete 

garbage collector for C++ is handled by programmers 


Exception handling 

Exception is an object thrown from site of error and can be caught by exception handlers 

declaration vs definition 

extern key word: definition is external to the file, or occurs later

headers 

linking 

linker collects object modules like .o or .obj generated by compiler 

Link the library into the executable program. 

class member function abc::aaa();


short int, int, long int

float, double, long double

singed, unsigned 

declare it using ::, use using dot

Destructor always same name but with ~symbol 

at most one destructor 

for class with pointer data 

a global
object is destroyed when program execution is completed; an automatic object is
destroyed when its scope is left; and a dynamic object is destroyed when the
delete operator is applied to it.

friend function

```
class RealSet{
friend void IntSet::SetToReal (RealSet&)
}

void IntSet::SetToReal (RealSet &set)
{
set.card = card;
for (register i = 0; i < card; ++i)
set.elems[i] = (float) elems[i];
}

```

default argument 

```
public:
    Point(int x = 0; int y = 0);
```

Within the body of the member function,
one can refer to this implicit argument explicitly as this, which denotes a pointer to
the object for which the member is invoked. 

```
Point::OffsetPt (int x, int y)
{
this->xVal += x; // equivalent to: xVal += x;
this->yVal += y; // equivalent to: yVal += y;
}
```

member initialization list
```

class Image {
public:
Image (const int w, const int h);
private:
int width;
int height;
 //...
};
Image::Image (const int w, const int h) : width(w), height(h)
{
//...
}

```

```
Bool Set::Member (const int elem) const
{
//...
}
for constant memeber function
```

A data member of a class can be defined to be static. This ensures that there will
be exactly one copy of the member, shared by all objects of the class. 


## Lecture 2 5/8 

default constructor 

parameterized constructor 

input operator overload 

```
Rational P;
Rational q {3, 5};
cin >> p;
cout << a << endl;
cout << p + q << endl;
rational Z {p, q }

```
operator + overload 

operator / overload 

copy constructor 

Does an ADT have to be a class 

No. Struct my ADT works 

Initialization is guaranteed constructors destructors 

enforce legal value range / can't do in C 

visibility of fields 

should a class always have a default constructor?

No. There are cases you NEED to pass your initialization value 

move constructor? 



Object construction in C++ 

1. Allocate Space 
2. Initialize superclass components 
   -- superclass will be default constructed unless told how to initialize it 
3. initialize all fields which are objects -- default unless otherwise
4. construct body elements 

MIL is now to tell compilers what constructors to use with which value 

without MIL you won't be able to default initialize the super class 

why use MIL

* need to if fields or superclass doesn't have a default constructor 

```
class A {
    public:
    A(int x) ...{ }
}

class B {
    A a;
    Public:
    B(){A.setX = 5} // before constructor body runs, trys to default construct A, but doesn't exist
}
```

* speed: if you don't initialize properly in MIL, field/superclass get default constructed, then you waste that time when you overwrite that default construction in the body. Better to do it the first time. 

-- smart pointer: delete automatically 

```
//+ between rationals
- between rationals
- << ostream and rational 
- >> operator >> between istream and rational 
should these be memeber function?
can they be?

cin >> r //first argument is istream

cout << r; 

overloaded operators as member functions always take object itself as the first parameter 

cannot support because first argument is different 


class Rational {
    int num_, den_;
    public:
        Rational(): num_{0}, den_{0} {} // member initialization list 
        Rational(int num): num_{num},den_{1} {}
        Rational(int num, int den): num_{num},den_{den} {}

        //use default parameter values
        easier to write:
        Rational(int num = 0, int den = 1) num_{num}, den_{den} {}
        //default parameters must be trailing : last n parameters after first default parameter, the after ones are default too
        Rational(const Rational &r): num_{r.num_}, den_(r.den_) {} 
        Rational operator + (const Rational& r ){
            //itself is *this 
        } //member function 
        //first param is implicitly the rational pointed to by the this pointer 
        // no choice of first parameter 
}

```

can't take the base class, but you can take the derived class

A <- B

foo (B b);
A a;
B b;
foo(a); //doesn't work 

output and input CAN't be member functions 

In general prefer non-member non-friend functions 

## Tutorial 1 

Legal value 

explicit Rational (int num)

constructor initalizes new object to a legal value 

Rational a = 4 

rational n = rational {4}

accessor don't change anything in your class 

overloading -- same function name for variants of the same function

different argument signatures

non member functions 

## Lecture 3

copy assignment operator

```
Rational& operator = (const Rational & other) {
  num = other.num_
  den = other.den_
  //not a constructor, no MIL 
  return *this; 
}

```
copy constructor 

```
Rational(const Rational & other) : num_{other.num_}, den_{other.den_}

```

friend Rational operator + (const Rational& lhs, const Rational& rhs){
// no implementation here, inside class
} // non member function, cannot access private information
// need to use friend fucntion 

outside class 

Rational operator + (const Rational& lhs, const Rational & rhs) {
 Rational p {lhs.num * rhs.den + rhs.num * lhs.den, lhs.den * rhs.den };
 retrun p;
}

or make it a member function:

Ratioanl operator+ (const Rational & rhs){
  ...
}

r = s, Copy Assignment Operator
s will be implicityly cast to s / 1 

Rational operator+ (int x){
  return Rational { x * den_ + num, den_}; // can do r + 7 but not 3 + r 
} //member function, doesn't work well

friend Rational operator+ (int x, const Rational &){
}

Ratioanl operator+(int x, const Rational& R){
  //
}

 
Rational r {1,2}

Rational p = r + 7,

Rational q = 3 + r

cin >> q >> p >> r;
cout << p; 

needs setters/getters or friend function

friend Ostream& operator <<(ostream&, const Rational &);
friend istream& operator >>(istream&, Rational&);

OStream & operator <<(Ostream& out, const Rational& r ){
  out << "r << r.num_... ;
}

istream& operator >> (istream & in, Rational & r){
  return in>>r.num_ >> r.dm_;
}


Class Node {
  int data_;
  Node* next_;
  Public:
    Node(int data, Node* next_ = nullptr): data_ {{data}, next{next_}
    Node(const Node& other): data{other.data}, next{
      other.next ? new Node{*other.next} : nullptr
    } {}
}

Node n {3, new node{ 2, new NOde{1}}},

3 -> 2 -> 1 

cout << n; 
Node p {n};
p.next -> data = 20,
cout << p // 3, 20, 1
cout << n // 3, 2, 1

deep copy, copy a whole new linked list

## Lecture 4 
```
#include <utility>

Class Node {
  int data_;
  Node* next_;
  Public:
    Node(int data, Node* next_ = nullptr): data_ {{data}, next{next_}
    Node(const Node& other): data{other.data}, next{
      other.next ? new Node{*other.next} : nullptr
    } {}
    ~Node(){
        //when object out of scope(stack) or deleted 
        //when new, always delete 
        delete next; // recursively called;
    }
    Node( Node && o) : next{o.next}, data{o.data // std::move(o.data)}{
        o.next = nullptr;
    } //rvalue reference, move constructor, copying an rvalue
    Node & operator=(const node & other){ //copy assignment operator
       Node* tmp = new Node{other};
       data = other.data;
       delete next; //can't fail
       next = temp; //can't fail
       retrun *this;

       //new version
       Node* temp{other};
       swap(data, tmp.data);
       swap(next, temp.next);
       return *this;
    } 

    Node & operator = (Node && other){ //rvalue reference again
        //need to deallocate previous next ptr 
        using std::swap,
        swap(data other.data);
        swap(next, other.next);
        return* this;
        /*
        data = other.data;
        delete next;
        next = other.next;
        other.next = nullptr;
        return *this;
        */ //too long
    }
}

Node n {3, new node{ 2, new NOde{1}}},

Node foo(){
    Node n...
    return n;
} // return node by value

int main(){
    Node n = foo(); // rvalues, temporary values, only exists here 
    //return value guaranteed not to exist after this statement 
}
```

lvalue is guaranteed to have a memory address

void bar(int & x){
    x = sss;
}
bar(5+3); //doesn't work

can't call bar on a r value because its type is an lvalue ref, make exception if its constant

The big 5 

destructor 

copy assignment operator

copy constructor

move constructor

move assignment operator


std::move takes in any type and returns an rvalue version of it 


## Lecture 5 

```
Node & Node::Operator=(const Node & other){ Copy Assignment operator

  delete next;
  next = new Node {*other.next};
  data = other.data;
  return *this;
}
```

new fails then dangling pointer;

n = n? 

Then other is the same object, so delete next would 

try deep copy it would get memory error 

check for self assignment 

2 objects are the same when same memeory address

if(this == & other) return *this;

General Rule of thumb: if you have to provide a user defined definition for one of the big 5, you should for all 5.

No hard rule when you need these, need to figure out when you actually write those, but at least when you have resources you need to maintain 

e.g Memory, Socket, File ptr etc...

when are these used ? 

- Destructor, when an object goes out of scope
- heap/dynamically allocated would be delete abc 
- statically allocated when their life time ends, when their enclosing scope ends 

Definition: static memory allocation is the allocation of memory at compile time, before the associated program is executed, unlike dynamic memory allocation or automatic memory allocation where memory is allocated as required at run time.

Class A{
  B b;
}

A &p = new A;

A object pointed to by p is dynamically allocated

p -> b is on the heap bits 

no need to delete a->b because its lifetime is tied to 

copy ctor is called 

- when you construct one object with another one of the same type 

- when a function receives an object param by value 

- when a function returns by value 

EXCEPT 

- when a move constructor is defined then it is used to return by value 

if the other cases use an rvalue as argument then the move ctor is used 


Compiler provides builtin impelmentations of thse for you 

copy ctor -- bytewise copies all PoD(built in types not String) fields and copy constructs all object fields 

same with move constructor 

copy assignment operator bytewise all PoD fields and copy assigns all object fields 

define CAO you would lose builtin MAO, just one way

If you define a copy constructor, you lose builtin move constructor , one way

### ADT 

Abstracting some complex idea of data 

enforce rules on that data e.g a valid range of values 

Node n {3, new node{2, nullptr}}{
  Node p{4, &n}
}

P goes out of scope, p's destructor runs, calls delete on its next pointer, a statistically allocated address 

can't call delete on stack allocated address 

we have some rules that must hold for our ADT to work properly 

Assumptions are claled invariants - properties that must hold true for code to work properly 

Client Code writer CANNOT be trusted to uphold your invariants 

Don't expect clients to remember the rules 

## Tutorial 2 

Inheritance 

Polymorphism 
derived class that public inherits from a base calss, 

use base class pointers to point to objects of derived type

access things that doesn't exist in the base class is wrong 

static binding:

By Default: binding of functions occurs at compile time

if call a member function from a polymorphic base class pointer, 

function called will be the base class implementation 

regardless of the actual object pointed to 

Virtual functions: dynamic binding, so it will find the actual class of the object pointed to. 

```
class Bear : public Animal{

}

```

Functions with multiple definitions 

Overriding, overloading 

Overriding: subclass with the same name function compared to super class 

member objects : initialized using member's default constructors 

inherited objects: initialized using base class default constructor 

Copy Constructor 

Node::Node(const Node & other){
  data(other.data),
  next(other.next ? )
}

copy and swap idiom 

avoid code duplication 

Assignment operator may be implemented by creating a new object of the same type with the copy constructor then swapping the old values of the obejct 

use std::swap 

Move: argument is rvalue reference

and resource in the argument is stealed to the object created or assigned 


MIL 

references and const members cannot be initialized outside the initialization list 

Any object not initialized in MIL will have its default constructor called 


## Lecture 6 

Invariants - Assumptions that must hold true for our code to work properly, hard/impossible to reason about code without them. 

```
Class Node{
  int data;
  Node *next;
  Public:
    Node(int d, Node* next){

    } -- no cycles 
    ~NOde(){delete next;}
}
```

Each next pointer must point at a valid heap allocated node, or the null ptr

Node assumes ownership of the next pointer 

Must be able to delete it 

No cycles, No sharing of next pointers 

curretnly in constructor they can do whatever they want to the Node* next parameter 

can't guarantee client behavior 

Allowing the client to use this constructor is dangerous, as allowing them to see Node or linked list at all is represnetation exposure 

The ADT we want to give to the client is a list : they should not have to care about the implementation 

it is a linked list of nodes here, but they don't need to care 

- what we want is to encapsulate the implementation logic, hide it away from client 

Give the client a list class 

//list.h 
```
class List {
  class Node { // private nested class 
    //same implementation
    friend class List;
  }
  Node *head;
  Public: 
    List()head{nullptr}{}
    List& push(int data);
    // big 5 for list, reusing Node code
    int& ith(size_t i);
}
```
//list.cc 

header file, i.e interface file  for .h 

.cc implmenetation, seperate compilation 
```
List::Node::Node(int data, Node* next) //how you use private nested class 
List& List::push(int data){
  head = new Node{data, head};
  return *this;
}
int & List::ith(size_t i){
  Node* Node = head;
  while(i > 0 && node){
    --i;
    node = node->next;
  }
  return node->data;
}
```
Client code:

```
#include<iostream>
using namespace std;

list l;
size_t en;
for(size_t i = 0;i < len; ++i){
  cout<< l.ith(i) <<endl;
}  // O(N^2)
```

- ith is O(n) and it's bad 
- don't have to call ith everytime they want to iterate through it 
- give the user a similar way to iterate over their list as they did before without exposing the representation 

what we want is an iterator 

Client code:

```
List l ;
for (thing = beginning of list, thing  != end of list; ++ thing){
  *thing = *thing + i;
  cout << *thing;
}
```

For iterator:
- get beginning of the list : iterator list::begin()
- get end of the list : iterator list::end()
- ++ work on the iterator 
- iterator::operator++()
- dereference operator iterator::operator*()
- inequality/equality operator between iterators